doctype html
html
 head
  meta(charset='UTF-8')
  meta(name='viewport' content='width=device-width, initial-scale=1')
  link(rel='shortcut icon' type='image/x-icon' href='favicon.ico')
  title TAG 2018/2019 - David y Javier
  link(rel='stylesheet' href='style.css' type='text/css' media='screen')
  // Código JS para los controles básicos de la página web
  script(src='manejar_controles_basicos.js' async='')
  // WebGL para el proyecto
  script(src='js/gl-matrix-min.js')
  script(src='js/twgl-full.min.js')
  script(src='http://twgljs.org/3rdparty/chroma.min.js')
  script(src='manejar_motor_grafico.js' type='module')
  script#vs(type='notjs').
    #version 300 es
    precision highp float;
    in vec4 a_position;
    in vec3 a_normal;
    in vec2 a_texcoord;
    
    in vec4 lightposition;
    in mat4 modelmatrix;
    in mat4 viewmatrix;
    in mat4 normalmatrix;
    in mat4 projecionmatrix;
    
    // varying to pass the normal to the fragment shader
    out vec2 v_texcoord;
    out vec3 Position;
    out vec3 Normal;
    
    out vec3 surfaceToLight;
    
    void main(void) {
      v_texcoord = a_texcoord;


      
      mat4 modelviewmatrix = viewmatrix * modelmatrix;
      mat4 mvp = projecionmatrix * viewmatrix * modelmatrix;
      vec3 surfaceWorldPosition = (modelmatrix * a_position).xyz; 
      
      Position = (modelviewmatrix * a_position).xyz;
      // Pass the normal to the fragment shader
      Normal = mat3(normalmatrix) * a_normal;
      
       
      
      surfaceToLight = vec3(lightposition) - surfaceWorldPosition;
      gl_Position = mvp * a_position;
    }
  script#fs(type='notjs').
    #version 300 es
    precision mediump float;

    in vec2 v_texcoord;

    // Passed in and varied from the vertex shader.
    in vec3 Normal;
    in vec3 surfaceToLight;

    uniform vec4 u_color;

    uniform sampler2D u_sampler;
    uniform vec4 u_diffuseMult;

    out vec4 outColor;
    void main(void) {
      // because Normal is a varying it's interpolated
      // so it will not be a uint vector. Normalizing it
      // will make it a unit vector again
      vec3 normal2 = normalize(Normal);
      vec3 surfaceToLightDirection = normalize(surfaceToLight);

      // compute the light by taking the dot product
      // of the normal to the light's reverse direction
      float light = dot(normal2, surfaceToLightDirection);
      
      outColor = u_color;
      outColor.rgb *= light;
    }

  body
    block content
