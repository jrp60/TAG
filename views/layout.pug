doctype html
html
 head
  meta(charset='UTF-8')
  meta(name='viewport' content='width=device-width, initial-scale=1')
  link(rel='shortcut icon' type='image/x-icon' href='favicon.ico')
  title TAG 2018/2019 - David y Javier
  link(rel='stylesheet' href='style.css' type='text/css' media='screen')
  // Código JS para los controles básicos de la página web
  script(src='manejar_controles_basicos.js' async='')
  // WebGL para el proyecto
  script(src='js/gl-matrix-min.js')
  script(src='js/twgl-full.min.js')
  script(src='http://twgljs.org/3rdparty/chroma.min.js')
  script(src='manejar_motor_grafico.js' type='module')
  script#vs(type='notjs').
    #version 300 es
    precision highp float;
    in vec4 a_position;
    in vec3 a_normal;
    in vec2 a_texcoord;
    out vec2 v_texcoord;
    // varying to pass the normal to the fragment shader
    out vec3 v_normal;
    void main(void) {
      gl_Position = a_position;
      v_texcoord = a_texcoord;
      // Pass the normal to the fragment shader
      v_normal = a_normal;
    }
  script#fs(type='notjs').
    #version 300 es
    precision mediump float;

    in vec2 v_texcoord;

    // Passed in and varied from the vertex shader.
    in vec3 v_normal;

    uniform vec3 u_reverseLightDirection;
    uniform vec4 u_color;

    uniform sampler2D u_sampler;
    uniform vec4 u_diffuseMult;

    out vec4 outColor;
    void main(void) {
      // because v_normal is a varying it's interpolated
      // so it will not be a uint vector. Normalizing it
      // will make it a unit vector again
      vec3 normal = normalize(v_normal);


      // compute the light by taking the dot product
      // of the normal to the light's reverse direction
      float light = dot(normal, u_reverseLightDirection);


      outColor = u_color;

      // Asi tenemos colores aleatorios en cada cara.
      outColor = vec4(v_texcoord, 1.0, 1.0);
 
      // Lets multiply just the color portion (not the alpha)
      // by the light
      outColor.rgb *= light;
      // gl_FragColor = vec4(0.0, 0.0, 0.0, 0.1);
      //- outColor = texture(u_sampler, v_texcoord) * u_diffuseMult;
      //- outColor = vec4(texture(u_sampler, v_texcoord).rgb, 0.5);
      //- outColor = texture(u_sampler, v_texcoord);
    }

  body
    block content
